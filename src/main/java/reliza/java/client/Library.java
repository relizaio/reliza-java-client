/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package reliza.java.client;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.io.FileUtils;
import lombok.extern.slf4j.Slf4j;
import okhttp3.OkHttpClient;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.databind.ObjectMapper;
import retrofit2.Call;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.jackson.JacksonConverterFactory;
import reliza.java.client.interceptors.BasicAuthInterceptor;
import reliza.java.client.responses.InstanceMetadata;
import reliza.java.client.responses.ProjectMetadata;
import reliza.java.client.responses.ProjectVersion;
import reliza.java.client.responses.ReleaseMetadata;

@Slf4j
public class Library {  
    Flags flags;
    RHService rhs;
    
    public Library(Flags flags) {
        this.flags = flags;
        ObjectMapper objectMapper = new ObjectMapper();
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        OkHttpClient client = new OkHttpClient.Builder()
            .addInterceptor(new BasicAuthInterceptor(flags.getApiKeyId(), flags.getApiKey()))
            .build();
        Retrofit retrofit = new Retrofit.Builder()
            .baseUrl("https://test.relizahub.com")
            .addConverterFactory(JacksonConverterFactory.create(objectMapper))
            .client(client)
            .build();
        this.rhs = retrofit.create(RHService.class);
    }
    
    
    public ReleaseMetadata approveRelease() {
        Map<String, Object> body = new HashMap<>();
        Map<String, Boolean> approvalMap = new HashMap<>();
        approvalMap.put(flags.getApprovalType(), !flags.getDisapprove());
        body.put("approvals", approvalMap);
        body.put("uuid", flags.getReleaseId());
        body.put("version", flags.getReleaseVersion());
        body.put("project", flags.getProjectId());    
        Call<ReleaseMetadata> call = rhs.approveRelease(body);
        return execute(call);
    }
    
    
    public ReleaseMetadata getLatestRelease() {
        Map<String, Object> body = new HashMap<>();
        body.put("project", flags.getProjectId());
        body.put("environment", flags.getEnvironment());
        body.put("product", flags.getEnvironment());
        if (StringUtils.isNotEmpty(flags.getTagKey()) && StringUtils.isNotEmpty(flags.getTagVal())) {
            body.put("tags", flags.getTagKey() + " " + flags.getTagVal());
        }
        body.put("branch", flags.getBranch());
        body.put("instance", flags.getInstance());
        body.put("namespace", flags.getNamespace());
        Call<ReleaseMetadata> call = rhs.getLatestRelease(body);
        return execute(call);
    }
    
    
    public List<ReleaseMetadata> getMyRelease() {
        Call<List<ReleaseMetadata>> call = rhs.getMyRelease(flags.getNamespace());
        return execute(call);
    }
    
    
    public InstanceMetadata instData() {        
        Map<String, Object> body = new HashMap<>();
        if (StringUtils.isNotEmpty(flags.getImageString())) {
            body.put("images", Arrays.asList(flags.getImageString().split(" ")));
        } else {
            try {
                byte[] imageBytes = FileUtils.readFileToByteArray(flags.getImageFilePath()); 
                body.put("images", Arrays.asList(new String(imageBytes, StandardCharsets.UTF_8).split(" ")));
            } catch (IOException e) {
                log.error("IO exception", e);
                return null;
            } catch (NullPointerException e) {
                log.error("NullPointerException", e);
                return null;
            }
        }       
        body.put("timeSent", Instant.now().toString());
        body.put("namespace", flags.getNamespace());
        body.put("senderId", flags.getSenderId());       
        Call<InstanceMetadata> call = rhs.instData(body);
        return execute(call);
    }
    
    
    public ProjectMetadata checkHash() {
        Map<String, Object> body = new HashMap<>();
        body.put("hash", flags.getHash());    
        Call<Map<String,ProjectMetadata>> call = rhs.checkHash(body);
        Map<String,ProjectMetadata> response = execute(call);
        if (response == null) {
            return null;
        }
        return response.get("release");
    }
    
    
    public ProjectMetadata addRelease() {
        Map<String, Object> body = new HashMap<>();
        body.put("branch", flags.getBranch());
        body.put("version", flags.getVersion());
        body.put("status", flags.getStatus());
        body.put("endpoint", flags.getEndPoint());
        body.put("project", flags.getProjectId());
        
        if (StringUtils.isNotEmpty(flags.getCommitHash())) {
            Map<String, String> commitMap = new HashMap<>();
            commitMap.put("commit", flags.getCommitHash());
            commitMap.put("uri", flags.getVcsUri());
            commitMap.put("type", flags.getVcsType());
            commitMap.put("vcsTag", flags.getVcsTag());
            commitMap.put("dateActual", flags.getDateActual());
            body.put("sourceCodeEntry", commitMap);
        }
        
        if (isNotEmpty(flags.getArtId())) {
            List<Map<String, Object>> artifacts = new ArrayList<Map<String, Object>>();   
            for (int i = 0; i < flags.getArtId().size(); i++) {
                Map<String, Object> artifact = new HashMap<>();
                artifact.put("identifier", flags.getArtId().get(i));
                artifacts.add(artifact);
            }
            
            Map<String, List<String>> artFlags = new HashMap<String, List<String>>();
            artFlags.put("buildId", flags.getArtBuildId());
            artFlags.put("cicdMeta", flags.getArtCiMeta());
            artFlags.put("type", flags.getArtType());
            artFlags.put("artifactVersion", flags.getArtVersion());
            artFlags.put("publisher", flags.getArtPublisher());
            artFlags.put("packageType", flags.getArtPackage());
            artFlags.put("group", flags.getArtGroup());
            artFlags.put("dateFrom", flags.getDateStart());
            artFlags.put("dateTo", flags.getDateEnd());

            for (String key : artFlags.keySet()) {
                if (isNotEmpty(artFlags.get(key)) && artFlags.get(key).size() != flags.getArtId().size()) {
                    log.error("number of art" + key.toLowerCase() + " flags must be either zero or match number of artid flags");
                    return null;
                } else if (isNotEmpty(artFlags.get(key))) {
                    for (int j = 0; j < flags.getArtId().size(); j++) {
                        artifacts.get(j).put(key, artFlags.get(key).get(j));
                    }
                }
            }
            
            if (isNotEmpty(flags.getArtDigests()) && flags.getArtDigests().size() != flags.getArtId().size()) {
                log.error("number of artdigests flags must be either zero or match number of artid flags");
                return null;
            } else if (isNotEmpty(flags.getArtDigests())) {
                for (int i = 0; i < flags.getArtId().size(); i++) {
                    artifacts.get(i).put("digests", Arrays.asList(flags.getArtDigests().get(i).split(",")));
                }
            }
            
            if (isNotEmpty(flags.getTagKeyArr()) && flags.getTagKeyArr().size() != flags.getArtId().size()) {
                log.error("number of tagkey flags must be either zero or match number of artid flags");
                return null;
            } else if (isNotEmpty(flags.getTagValArr()) && flags.getTagValArr().size() != flags.getArtId().size()) {
                log.error("number of tagval flags must be either zero or match number of artid flags");
                return null;
            } else if (isNotEmpty(flags.getTagKeyArr()) && !isNotEmpty(flags.getTagValArr())) {
                log.error("number of tagval and tagkey flags must be the same and must match number of artid flags");
                return null;
            } else if (isNotEmpty(flags.getTagKeyArr())) {
                for (int i = 0; i < flags.getTagKeyArr().size(); i++) {
                    List<String> tagKeys = Arrays.asList(flags.getTagKeyArr().get(i).split(","));
                    List<String> tagVals = Arrays.asList(flags.getTagValArr().get(i).split(","));
                    if (isNotEmpty(tagKeys) && isNotEmpty(tagVals) && tagKeys.size() != tagVals.size()) {
                        log.error("number of keys and values per each tagval and tagkey flag must be the same");
                        return null;
                    }    
                    Map<String, String> tagKeyToVal = new HashMap<>();
                    for (int j = 0; j < tagKeys.size(); j++) {
                        tagKeyToVal.put(tagKeys.get(j), tagVals.get(j));
                    }
                    artifacts.get(i).put("tags", tagKeyToVal);        
                }
            }
            body.put("artifacts", artifacts);
        }   
        Call<ProjectMetadata> call = rhs.addRelease(body);
        return execute(call);
    }
        
    
    public ProjectVersion getVersion() {
        Map<String, Object> body = new HashMap<>();  
        body.put("branch", flags.getBranch());
        body.put("versionSchema", flags.getVersionSchema());
        body.put("project", flags.getProjectId());
        Call<ProjectVersion> call = rhs.getVersion(body);
        return execute(call);
    }  
    
    private static <T> T execute(Call<T> call) {
        try {
            Response<T> resp = call.execute();
            if (resp.isSuccessful()) {
                log.info(resp.body().toString());
                return resp.body();
            } else {
                log.error(resp.errorBody().string());
                return null;
            }
        } catch (IOException e) {
            log.error("IO exception", e);
            return null;
        }
    }
    
    private static <T> boolean isNotEmpty(List<T> flag) {
        return flag != null && flag.size() > 0;
    }
}